## Отчет по лабораторной работе №2

### 1) Утилиты резервного копирования

Логический бэкап (pg_dump) - это резервная копия, созданная на уровне SQL-запросов. \
Вместо копирования физических файлов базы данных, логический бэкап генерирует набор SQL-команд, которые позволяют воссоздать структуру и содержимое базы данных.

Сценарии применения\
•	Перенос данных между различными версиями PostgreSQL или платформами.\
•	Резервное копирование одной базы данных (или её части, например, таблиц или схем).\
•	Создание выборочной копии (например, только схемы или только данные).\
•	Гибкость восстановления: можно восстановить отдельные объекты или изменить порядок восстановления.

Преимущества\
•	Подходит для переноса между различными версиями PostgreSQL или операционными системами.\
•	Возможность выборочного восстановления объектов.

Физический бэкап (pd_basebackup) — это метод резервного копирования,\
при котором производится прямое копирование бинарных файлов базы данных,\
включая файлы данных, журналы и индексные файлы. \
Это создание полной двоичной копии всех файлов, относящихся к кластеру базы данных.

Сценарии применения\
•	Настройка репликации: создание резервной копии для standby-сервера.\
•	Быстрое восстановление системы после сбоя.\
•	Point-In-Time Recovery (PITR): восстановление до определённой точки времени при наличии WAL-журналов.

Преимущества\
•	Полная копия кластера PostgreSQL, включая все базы данных.\
•	Подходит для быстрого восстановления.\
•	Возможность восстановления до любой точки времени при наличии архивированных WAL-журналов.

### 2) Создание резервной копии

Выполняем бэкапы бд:

<img width="690" alt="Снимок экрана 2025-04-11 в 20 36 59" src="https://github.com/user-attachments/assets/aa8ec31a-4cb2-403f-9ab0-9d5bfe5aad7a" />

-Fc – кастомный формат PostgreSQL, позволяет выборочно восстанавливать объекты,\
только схемы или данные например. Поддерживает восстановление с помощью pg_restore.

-Ft – формат архива tar, удобен для переносимости, так как создаёт единый файл,\
который можно легко переместить. Поддерживает восстановление с помощью pg_restore.

Дополнительные параметры:\
  -s: Сохраняет только схему базы данных (без данных).\
  -a: Сохраняет только данные (без схемы).\
  -t: Сохраняет данные только из указанной таблицы.\
  -n: Сохраняет объекты из указанной схемы.

### 3) Частичное (выборочное) резервное копирование

Сохраняем схему bleg_schema из dbleg:

<img width="1099" alt="Снимок экрана 2025-04-11 в 20 57 39" src="https://github.com/user-attachments/assets/ed4a6e00-1266-4b37-8b87-e76e3be424f6" />

Сохраняем таблицу из схемы public в базе dbbleg:

pg_dump -U postgres -d dbbleg -n public -t mytable > mytable_dump.sql.


### 4) Восстановление из резервной копии

Создаем бд dbbleg_bckp и pосстанавливаем базу данных из файла dbbleg.sql:

<img width="658" alt="Снимок экрана 2025-04-11 в 21 05 21" src="https://github.com/user-attachments/assets/5491e5a1-d8b3-4154-90d9-a40bb5e8b163" />

Выводим таблицы из базы данных dbbleg, чтобы сравнить с бэкапом:

<img width="432" alt="Снимок экрана 2025-04-11 в 21 19 06" src="https://github.com/user-attachments/assets/8889a7bf-323f-4fed-ad1a-06f87ca4799c" />

Таблицы из базы данных dbbleg_bckp:

<img width="462" alt="Снимок экрана 2025-04-11 в 21 19 13" src="https://github.com/user-attachments/assets/40213b50-8fc0-45a9-8d1b-8c5871eafb1d" />

ПРИМЕЧАНИЕ: файл резервной копии базы данных создавался до того, как в неё был добавлена новая таблица, что подтвержает достоверность резервной копии.

### 5) Автоматизация бэкапов с помощью cron

Создание скрипта и последующая настройка на автовыполнение скрипта каждую минуту:

<img width="743" alt="Снимок экрана 2025-04-11 в 21 57 05" src="https://github.com/user-attachments/assets/101bc47c-cdfe-43a5-aa42-dce4d4c52f54" />

- в нижней строке добавляем следующее: * * * * * /home/bleg/sepecod.sh (время обновления и путь к файлу автоматизации)

### 6) Мониторинг состояния системы

Выполняем команду top:

<img width="1013" alt="Снимок экрана 2025-04-11 в 22 03 56" src="https://github.com/user-attachments/assets/b23320ed-95df-4b8d-bf3c-0e2ca5a941c7" />


•	PID: Идентификатор процесса PostgreSQL.\
•	USER: Пользователь, под которым запущен процесс (обычно postgres).\
•	%CPU: Процент использования CPU процессом.\
•	%MEM: Процент использования оперативной памяти процессом.\
•	TIME+: Общее время работы процесса на CPU.\
•	COMMAND: Имя команды или процесса (например, postgres: writer process).

Выполняем команду htop:

<img width="925" alt="Снимок экрана 2025-04-12 в 00 32 40" src="https://github.com/user-attachments/assets/eb7f6375-7001-4f95-8d0f-936233933257" />


PID → Идентификатор процесса\
USER → Владелец процесса\
PRI → Приоритет процесса (чем ниже, тем важнее)\
NI → "Nice" уровень (чем ниже, тем больше процессу дают CPU)\
VIRT → Виртуальная память, используемая процессом\
RES → Реально используемая память (без swap)\
SHR → Разделяемая память (используемая совместно с другими процессами)\
S → Состояние (S – спит, R – работает, Z – зомби)\
%CPU → Использование CPU процессом\
%MEM → Использование памяти\
TIME+ → Время работы процесса\
COMMAND → Запущенная команда



### 7) Мониторинг PostgreSQL

Просмотр активных процессов:

<img width="594" alt="Снимок экрана 2025-04-12 в 01 05 49" src="https://github.com/user-attachments/assets/65743d19-b886-405b-81c2-9a91aeb2ea77" />

Просмотр статистики по базам данных:

<img width="949" alt="Снимок экрана 2025-04-12 в 01 15 27" src="https://github.com/user-attachments/assets/0907a38c-55bb-4944-a766-57d82a7a468f" />

Завершение зависшего процесса:\
SELECT pg_terminate_backend(<pid>);

### 8) Логирование и анализ логов 

Вывод системных логов:

<img width="1023" alt="Снимок экрана 2025-04-12 в 01 24 14" src="https://github.com/user-attachments/assets/8d028b7e-444a-493a-bebc-b4a78c7542d9" />








